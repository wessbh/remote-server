"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FailedToExtractResourcesInTerraformPlanError = exports.tryParsingTerraformPlan = exports.isTerraformPlan = void 0;
const types_1 = require("../types");
const errors_1 = require("../../../../../lib/errors");
function terraformPlanReducer(scanInput, resource) {
    // TODO: investigate if this reduction logic covers all edge-cases (nested modules, similar names, etc')
    const { type, name, mode, index, values } = resource;
    const inputKey = mode === 'data' ? 'data' : 'resource';
    if (scanInput[inputKey][type]) {
        // add new resources of the same type with different names
        scanInput[inputKey][type][index !== undefined ? `${name}_${index}` : name] =
            values || {};
    }
    else {
        // add a new resource type
        scanInput[inputKey][type] = { [name]: values };
    }
    return scanInput;
}
function resourceChangeReducer(scanInput, resource) {
    // TODO: investigate if we need to address also `after_unknown` field.
    const { actions, after } = resource.change || { actions: [], after: {} };
    if (isValidResourceActions(actions)) {
        const resourceForReduction = Object.assign(Object.assign({}, resource), { values: after || {} });
        return terraformPlanReducer(scanInput, resourceForReduction);
    }
    return scanInput;
}
function isValidResourceActions(action) {
    return types_1.VALID_RESOURCE_ACTIONS.some((validAction) => {
        if (action.length !== validAction.length) {
            return false;
        }
        return validAction.every((field, idx) => action[idx] === field);
    });
}
function extractRootModuleResources(terraformPlanJson) {
    var _a, _b;
    return ((_b = (_a = terraformPlanJson.planned_values) === null || _a === void 0 ? void 0 : _a.root_module) === null || _b === void 0 ? void 0 : _b.resources) || [];
}
function extractChildModulesResources(terraformPlanJson) {
    var _a, _b;
    const childModules = ((_b = (_a = terraformPlanJson === null || terraformPlanJson === void 0 ? void 0 : terraformPlanJson.planned_values) === null || _a === void 0 ? void 0 : _a.root_module) === null || _b === void 0 ? void 0 : _b.child_modules) || [];
    const extractedChildModuleResources = [];
    childModules.forEach((childModule) => childModule.resources.forEach((resource) => extractedChildModuleResources.push(resource)));
    return extractedChildModuleResources;
}
function extractResourceChanges(terraformPlanJson) {
    return terraformPlanJson.resource_changes || [];
}
function extractResourcesForFullScan(terraformPlanJson) {
    const rootModuleResources = extractRootModuleResources(terraformPlanJson);
    const childModuleResources = extractChildModulesResources(terraformPlanJson);
    return [
        ...rootModuleResources,
        ...childModuleResources,
    ].reduce(terraformPlanReducer, { resource: {}, data: {} });
}
function extractResourcesForDeltaScan(terraformPlanJson) {
    const resourceChanges = extractResourceChanges(terraformPlanJson);
    return resourceChanges.reduce(resourceChangeReducer, {
        resource: {},
        data: {},
    });
}
function isTerraformPlan(terraformPlanJson) {
    var _a;
    const missingRequiredFields = !((_a = terraformPlanJson.planned_values) === null || _a === void 0 ? void 0 : _a.root_module) ||
        terraformPlanJson.resource_changes === undefined;
    return !missingRequiredFields;
}
exports.isTerraformPlan = isTerraformPlan;
function tryParsingTerraformPlan(terraformPlanFile, terraformPlanJson, { isFullScan } = { isFullScan: false }) {
    try {
        const scannableInput = isFullScan
            ? extractResourcesForFullScan(terraformPlanJson)
            : extractResourcesForDeltaScan(terraformPlanJson);
        return [
            Object.assign(Object.assign({}, terraformPlanFile), { jsonContent: scannableInput, engineType: types_1.EngineType.Terraform }),
        ];
    }
    catch (err) {
        throw new FailedToExtractResourcesInTerraformPlanError();
    }
}
exports.tryParsingTerraformPlan = tryParsingTerraformPlan;
// This error is due to the complex reduction logic, so it catches scenarios we might have not covered.
class FailedToExtractResourcesInTerraformPlanError extends errors_1.CustomError {
    constructor(message) {
        super(message || 'Failed to extract resources from Terraform plan JSON file');
        this.code = types_1.IaCErrorCodes.FailedToExtractResourcesInTerraformPlanError;
        this.userMessage =
            'We failed to extract resource changes from the Terraform plan file, please contact support@snyk.io, if possible with a redacted version of the file';
    }
}
exports.FailedToExtractResourcesInTerraformPlanError = FailedToExtractResourcesInTerraformPlanError;
//# sourceMappingURL=terraform-plan-parser.js.map